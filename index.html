<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Fractal Compression Demo</title>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      font-family: system-ui, sans-serif;
      margin: 2rem;
      display: grid;
      gap: 1.5rem;
    }
    section {
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 12px;
      padding: 1.5rem;
    }
    h2 {
      margin-top: 0;
      font-size: 1.35rem;
    }
    figure {
      margin: 1rem 0 0;
      padding: 0.75rem;
      border: 1px solid rgba(0,0,0,0.08);
      border-radius: 10px;
      background: rgba(0,0,0,0.02);
    }
    figure img {
      display: block;
      max-width: 100%;
      height: auto;
      margin: 0 auto 0.5rem;
    }
    figure img.intro-diagram {
      width: 30%;
    }
    figure figcaption {
      font-size: 0.95rem;
      text-align: center;
      color: rgba(0,0,0,0.7);
    }
    canvas, img {
      border: 1px solid rgba(0,0,0,0.2);
      image-rendering: pixelated;
    }
    #originalPreview {
      width: 256px;
      height: 256px;
      object-fit: contain;
    }
    #decompressCanvas {
      width: 256px;
      height: 256px;
    }
    button {
      margin-top: 0.75rem;
      margin-right: 0.5rem;
      padding: 0.5rem 1rem;
      font-size: 1rem;
      cursor: pointer;
    }
    #status {
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      white-space: pre-wrap;
      margin-top: 1rem;
      max-height: 12rem;
      overflow-y: auto;
      border: 1px solid rgba(0,0,0,0.1);
      padding: 1rem;
      border-radius: 8px;
    }
    #workCanvas {
      display: none;
    }
  </style>
</head>
<body>
  <section>
    <h2>Fractal Compression</h2>
    <h3>Background</h3>
    <p>
      We model a grayscale image as a vector \(x \in [0,1]^n\) with \(n = H \times W\) and write \(\mathcal{I} = [0,1]^n\) for the image space.
      A transform \(f : \mathcal{I} \to \mathcal{I}\) is a contraction when \(|f(x) - f(y)| \leq k |x - y|\) for some \(k < 1\).
      The <a href="https://en.wikipedia.org/wiki/Banach_fixed-point_theorem" target="_blank" rel="noopener noreferrer">Banach fixed-point theorem</a> then tells us that every contraction admits a unique fixed point \(x^* \in \mathcal{I}\) with \(f(x^*) = x^*\).
    </p>
    <p>
      Moreover, for any starting image \(x \in \mathcal{I}\), the sequence \(x, f(x), f(f(x)), \ldots\) converges to \(x^*\).
      Fractal compression searches for a contraction \(f\) whose fixed point closely approximates the target image.
      Once such an \(f\) is found, we store its parameters instead of the pixels, because iteratively applying \(f\) to any seed image converges back to the fixed point.
      When the description of \(f\) is shorter than the original data, the image is effectively compressed.
    </p>
    <p>
      To make this concrete, we subdivide the image into a grid of blocks and assemble a family of contractions \(f_i\) whose combined action covers the entire image.
      We refer to the smaller target patches as <em>range</em> blocks, and to the larger source patches from which we reuse detail as <em>domain</em> blocks.
    </p>
    <figure>
      <img class="intro-diagram" src="grid_contraction.svg" alt="Block mapping from a coarse 2×2 domain to a fine 4×4 range" />
      <figcaption>
        The arrow illustrates a mapping \(f_i\) from a large domain block onto a smaller range block.
      </figcaption>
    </figure>
    <p>
      The illustration highlights the core idea: a domain block (one cell in the coarse grid) is contracted onto a range block in the finer grid.
      For each range block we therefore search for a domain block and a contraction that brings the transformed pixels as close as possible to the target block, ensuring the overall image stays close to the fixed point.
    </p>
    <h3>Implementation</h3>
    <p>
      This demo instantiates the blockwise contractions described above on 512×512 grayscale images.
      For every 4×4 <em>range</em> block we examine each candidate 8×8 <em>domain</em> block in the image, downsample it to the range resolution, and enumerate the eight spatial symmetries so every rotated or reflected variant is considered.
      For each candidate we solve for a simple intensity contraction—contrast \(c\) and offset \(d\)—that minimizes the mean-squared difference between the transformed domain block and the current range block.
      The parameters with the lowest error define one of the contractions \(f_i\); collecting these local winners yields a global mapping whose fixed point aims to reproduce the source image.
    </p>
    <p>
      We record these choices in a mapping table: each entry remembers the domain index, symmetry, and contrast/offset pair.
      During decompression the table is iterated repeatedly, with each pass replacing every range block by its contracted domain partner so the noisy seed image converges to the fixed point.
    </p>
  </section>

  <section>
    <h2>1. Source Image</h2>
    <p>Choose an image (any size); it will be converted to grayscale and resized to 512×512 for compression.</p>
    <input type="file" id="imageInput" accept="image/*" />
    <div>
      <img id="originalPreview" alt="Original preview" />
    </div>
  </section>

  <section>
    <h2>2. Compress</h2>
    <p>Runs the fractal encoder (8×8 → 4×4 mapping with symmetries &amp; contrast/offset fitting). Result stays in memory.</p>
    <button id="compressButton" disabled>Compress Image</button>
  </section>

  <section>
    <h2>3. Decompress</h2>
    <p>The canvas starts as random noise. Apply the stored mapping to iterate toward the original image.</p>
    <div>
      <canvas id="decompressCanvas" width="512" height="512"></canvas>
    </div>
    <div>
      <button id="iterateButton" disabled>Iterate Once</button>
      <button id="iterate8Button" disabled>Run 8 Iterations</button>
      <button id="resetButton" disabled>Reset Noise</button>
    </div>
    <div id="iterationLabel">Iterations: 0</div>
  </section>

  <section>
    <h2>Status</h2>
    <div id="status">Load an image to begin.</div>
  </section>

  <canvas id="workCanvas" width="512" height="512"></canvas>

  <script src="fractal.js"></script>
  <script>
    const SIZE = FractalCodec.IMAGE_SIZE;

    const imageInput = document.getElementById('imageInput');
    const compressButton = document.getElementById('compressButton');
    const iterateButton = document.getElementById('iterateButton');
    const iterate8Button = document.getElementById('iterate8Button');
    const resetButton = document.getElementById('resetButton');
    const statusBox = document.getElementById('status');
    const iterationLabel = document.getElementById('iterationLabel');
    const preview = document.getElementById('originalPreview');

    const workCanvas = document.getElementById('workCanvas');
    const workCtx = workCanvas.getContext('2d');
    const decompressCanvas = document.getElementById('decompressCanvas');
    const decompressCtx = decompressCanvas.getContext('2d');

    let loadedImagePixels = null; // Float64Array of size 512*512
    let mapping = null;
    let currentImage = null; // Float64Array for decompression state
    let iterations = 0;

    function setStatus(text) {
      statusBox.textContent = text;
    }

    function appendStatus(text) {
      statusBox.textContent += `\n${text}`;
    }

    async function loadImage(file) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => {
          workCtx.clearRect(0, 0, SIZE, SIZE);
          workCtx.drawImage(img, 0, 0, SIZE, SIZE);
          preview.src = workCanvas.toDataURL();
          URL.revokeObjectURL(url);
          resolve();
        };
        img.onerror = (e) => {
          URL.revokeObjectURL(url);
          reject(e);
        };
        img.src = url;
      });
    }

    function extractGrayscalePixels() {
      const imageData = workCtx.getImageData(0, 0, SIZE, SIZE);
      const src = imageData.data;
      const gray = new Float64Array(SIZE * SIZE);
      for (let i = 0, p = 0; i < src.length; i += 4, p++) {
        const r = src[i];
        const g = src[i + 1];
        const b = src[i + 2];
        gray[p] = 0.299 * r + 0.587 * g + 0.114 * b;
      }
      return gray;
    }

    function renderCurrentImage() {
      const imageData = decompressCtx.createImageData(SIZE, SIZE);
      const dest = imageData.data;
      for (let i = 0; i < currentImage.length; i++) {
        const value = Math.max(0, Math.min(255, Math.round(currentImage[i])));
        const base = i * 4;
        dest[base] = value;
        dest[base + 1] = value;
        dest[base + 2] = value;
        dest[base + 3] = 255;
      }
      decompressCtx.putImageData(imageData, 0, 0);
      iterationLabel.textContent = `Iterations: ${iterations}`;
    }

    function resetDecompressImage() {
      currentImage = new Float64Array(SIZE * SIZE);
      for (let i = 0; i < currentImage.length; i++) {
        currentImage[i] = Math.random() * 255;
      }
      iterations = 0;
      renderCurrentImage();
      appendStatus('Decompression buffer reset to random noise.');
    }

    async function handleCompress() {
      if (!loadedImagePixels) {
        return;
      }
      setStatus('Compressing...');
      await new Promise((resolve) => setTimeout(resolve, 10));
      const start = performance.now();
      mapping = FractalCodec.compressFromPixels(loadedImagePixels);
      const duration = (performance.now() - start) / 1000;
      appendStatus(`Compression complete in ${duration.toFixed(2)} seconds.`);
      iterateButton.disabled = false;
      iterate8Button.disabled = false;
      resetButton.disabled = false;
      resetDecompressImage();
    }

    function iterateOnce() {
      if (!mapping || !currentImage) {
        return;
      }
      currentImage = FractalCodec.iterate(currentImage, mapping);
      iterations += 1;
      renderCurrentImage();
    }

    function iterateEight() {
      if (!mapping || !currentImage) {
        return;
      }
      const start = performance.now();
      for (let i = 0; i < 8; i++) {
        currentImage = FractalCodec.iterate(currentImage, mapping);
        iterations += 1;
      }
      renderCurrentImage();
      const duration = (performance.now() - start) / 1000;
      appendStatus(`Ran 8 iterations in ${duration.toFixed(2)} seconds.`);
    }

    imageInput.addEventListener('change', async (event) => {
      const [file] = event.target.files;
      if (!file) {
        setStatus('Load an image to begin.');
        compressButton.disabled = true;
        return;
      }
      setStatus('Loading image...');
      try {
        await loadImage(file);
        loadedImagePixels = extractGrayscalePixels();
        setStatus('Image ready. Press "Compress Image" to encode.');
        compressButton.disabled = false;
      } catch (error) {
        console.error(error);
        setStatus('Failed to load image. Try a different file.');
        compressButton.disabled = true;
      }
    });

    compressButton.addEventListener('click', () => {
      handleCompress().catch((error) => {
        console.error(error);
        appendStatus(`Compression error: ${error.message}`);
      });
    });

    iterateButton.addEventListener('click', iterateOnce);
    iterate8Button.addEventListener('click', iterateEight);
    resetButton.addEventListener('click', resetDecompressImage);

    // Initialize decompression canvas with noise even before compression
    resetDecompressImage();
    compressButton.disabled = true;
  </script>
</body>
</html>
